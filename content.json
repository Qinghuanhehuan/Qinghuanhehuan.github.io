[{"title":"文件拓展名截取、选取今天是周几写法","date":"2018-05-28T05:39:50.000Z","path":"2018/05/28/文件拓展名截取、选取今天是周几写法/","excerpt":"文件拓展名截取之前的方案const extname = (filename) =&gt; { let arr = filename.split(\".\"); let len = arr.length; let extname='' if(len &gt; 1){ extname = arr[len-1]; extname = arr[len-2]==''?'': `.${extname}`; return extname } return extname } 改进后的方案：增加几种情况 点后无后缀 无点 有点，前面无文件名 const extname2 = (filename) =&gt; { let index = filename.lastIndexOf(\".\"); let len = filename.length if(index &lt;= 0||index == len-1){ return '' }else{ return filename.substring(index,len) } }","tags":[{"name":"js优化","slug":"js优化","permalink":"http://yoursite.com/tags/js优化/"}]},{"title":"ES6总结（二）","date":"2018-05-25T02:28:50.000Z","path":"2018/05/25/ES6总结（二）/","excerpt":"","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6总结（一）","date":"2018-05-24T02:28:43.000Z","path":"2018/05/24/ES6总结（一）/","excerpt":"前言这篇是个人总结的ES6用法，可能是不全面，但项目开发中用到的ES6语法基本都有。 let和const命令作用域的概念ES5：全局作用域和函数作用域ES6：块级作用域；严格模式 如何使用let和const let声明的变量只在自己的作用域内有效； let不能重复定义变量； const声明一个常量，不能修改； const声明的时候必须赋值； const可以修改一个对象的数值，因为const保存的是对象的指针，并不保存对象本身；","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"技术人员如何规划职业道路","date":"2018-05-23T01:44:10.000Z","path":"2018/05/23/技术人员如何规划职业道路/","excerpt":"前言： 前段时间在微信直播群里听到了前阿里钉钉技术总监、现准上市公司技术合伙人/副总裁武彻老师的技术分享：如何从小白成长为技术合伙人。刚听完觉得就是一些假大空的套话，将一些不痛不痒的理论并不能对实际开发做什么指导。但是，这段时间我一直在想，既然是成功者的分享也是有一定的借鉴之处，只靠一场技术分享就能有很多收获或进步是不可能的，开发经验的累积和思考，一步步的积累才会有所进步。真正让人感到“痛苦”的成长，才会有收获。下面是关于直播的一些分享： 1.技术的价值先进生产力一个公司技术团队的稳健是实现一切需求的基石，尤其需求在不同阶段对产品质量以及响应方面的高要求。 实现需求三步曲 勉强做出来 独挡一面 成为tl","tags":[{"name":"分享","slug":"分享","permalink":"http://yoursite.com/tags/分享/"}]},{"title":"TypeScipt入门","date":"2018-04-11T08:15:50.000Z","path":"2018/04/11/TypeScipt入门/","excerpt":"TypeScript是什么？ TypeScript是由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。 TypeScript 扩展了 JavaScript 的句法，所以任何现有的 JavaScript 程序可以不加改变的在 TypeScript 下工作。TypeScript 是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。 安装：npm install -g typescript编译：tsc app.ts # app.ts =&gt; app.js TypeScript数据类型 Boolean类型： 1let isDone: boolean = false; // tsc =&gt; var isDone = false; Number类型： 1let count: number = 10; // tsc =&gt; var count = 10; String类型： 1let name: string = 'Semliker'; // tsc =&gt; var name = 'Semliker'; Array类型： 12let list: number[] = [1,2,3]; // tsc =&gt; var list = [1,2,3];let list: Array&lt;number&gt; = [1,2,3]; // tsc =&gt; var list = [1,2,3]; Enum类型： 1234567enum Direction &#123; NORTH， SOUTH， EAST， WEST&#125;;let dir: Direction = Direction.NORTH; Any（动态类型）： 1234567let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false;=&gt; tsc =&gt;var notSure = 4;notSure = \"maybe a string instead\";notSure = false;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"TypeScipt","slug":"TypeScipt","permalink":"http://yoursite.com/tags/TypeScipt/"}]},{"title":"Angular2入门","date":"2018-04-09T02:28:22.000Z","path":"2018/04/09/Angular2入门/","excerpt":"Angular起源2009年，Misko hevery和Adam Abrons在业务时间创造了GetAngular 迭代之路 12年6月，AngularJS1.0.0正式版推出：亮点功能基本齐备，如双向绑定、依赖注入、指令等 AngularJS 1.3.x放弃支持IE8浏览器：推出了单次绑定语法 AngularJS 1.5.x增加类似组件式书写体验：主要是为过渡Angular2做铺垫 AngularJS 1.x的困境 饱受诟病的性能问题：脏检查 落后于当前Web发展理念（如组件开发方式） 对手机端不够友好：并没有考虑移动端的适配；太笨重","tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"浅谈pc和移动端的事件机制","date":"2017-10-11T06:58:01.000Z","path":"2017/10/11/浅谈pc和移动端的事件机制/","excerpt":"事件机制： 在事件机制中，有3样最重要的东西： 事件生产者 事件对象 事件消费者 事件生产者可以产生一系列的事件对象，然后事件对象携带着必要的信息，传递给事件消费者。 单向的消息传递模型：事件消息总是由事件生产者传递给事件消费者； 双向的消息传递模型：让两者同时作为事件生产者和事件消费者；一个事件生产者产生的事件可以对应有多个事件消费者；一个事件消费者也可以接受多个事件生产者产生的事件消息； 事件流及事件绑定 EMCAScript标准规定事件流包含三个阶段：事件捕获阶段（传递过程），处于目标阶段，事件冒泡阶段（响应过程）。 target.addEventListener(type, listener, useCapture); // 标准注册事件函数 // target:文档节点、document、window 或 XMLHttpRequest。 // 函数的参数：注册事件类型type，事件的回调函数，事件注册在捕获期间还是冒泡期间 // 例如：给button注册onclick事件，要是在捕获阶段注册，则 button.addEventListener(\"click\",function(){},true); target.removeEventListener(type, listener, useCapture); //在某一个元素上撤销已注册的事件。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"微信自动播放音频（视频同理）","date":"2017-10-09T06:49:43.000Z","path":"2017/10/09/微信自动播放音频（视频同理）/","excerpt":"","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"}]},{"title":"HTTP状态码301与302详解及区别","date":"2017-09-30T06:50:40.000Z","path":"2017/09/30/HTTP状态码301与302详解及区别/","excerpt":"301 redirect: 301 代表永久性转移(Permanently Moved) 302 redirect: 302 代表暂时性转移(Temporarily Moved ) 详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 什么是重定向？就是地址A跳转到地址B。百度百科的解释：重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"HTTP基本概念","date":"2017-09-29T06:50:06.000Z","path":"2017/09/29/HTTP基本概念/","excerpt":"什么是HTTP HTTP是干嘛用的？ 学名：超文本传输协议，是一种网络协议。它是基于TCP/IP的应用层协议。被设计用于web浏览器和web服务器之间的通信，也可以用于其他目的。 因为是专门用来传输诸如HTML的超媒体文档等web内容的。因为HTML本身就是超文本标记语言，HTML中包含文本、图片、音视频等内容，所以用来传输它的协议自然就叫超文本传输协议了。 它是web上数据交换的基础，是一种client-server协议，请求通常是由浏览器发起。一个完整的web文档由不同的子文档重新组建成的，如文本，布局描述，图片，视频，脚本等。 怎么和服务器通信？ HTTP遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。 客户端和服务端通过交互各自的消息（与数据流正好相反）来进行交互。通常由浏览器这样的客户端发出的消息叫做requests，那么被服务端回应的消息就叫做response。 HTTP被设计于20世纪90年代初，是一种可扩展的应用层协议。虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP或TLS-加密的TCP连接来发送。因为它有很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档内容来更新网页。 HTTP遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务端响应。HTTP是无状态协议，意味着服务器不会再两个请求之间保留任何数据（状态）。虽然通常基于TCP/IP层，但可以在任何可靠的传输层上使用：如一个不会静默丢失消息的协议，UDP。 HTTP的基本性质 总结：简单、可扩展、无状态 HTTP是简单的：即便在HTTP/2中把HTTP消息封装到frames中，HTTP大体上还是被设计成可读的且简单的。HTTP的消息能够让人读懂且明白它的意思，还允许简单的测试，放低了门槛，更有利于新来者了解。 HTTP是可扩展的：在HTTP/1中就出现了，HTTP headers让协议扩展变得非诚容易。只要服务端和客户端在新的headers上语义达成一致，新的功能就可以轻松地被加进来。 HTTP是无状态，有会话的：HTTP是无状态的，在同一个连接中，两个成功执行的请求之间是没有关系的。这就带来一个问题，用户没办法在一个网站进行连续的交互，比如在一个电商网站里，用户把某个商品加入了购物车中，换了一个页面后再次添加商品，两次添加的请求没有联系，浏览器无法知道最终用户都选择了哪些商品。而用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话来让每次请求都能共享相同的上下文信息，相同的状态。而HTTP的核心是无状态的，cookies的使用可以创建有状态的会话。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"js设置css样式的几种方式","date":"2017-09-28T06:49:03.000Z","path":"2017/09/28/js设置css样式的几种方式/","excerpt":"","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"移动端字体放大问题的研究","date":"2017-09-27T06:47:28.000Z","path":"2017/09/27/移动端字体放大问题的研究/","excerpt":"问题背景： 很多webview提供了调整页面字体大小的功能，例如手机QQ、微信、部分Android内置浏览器等。大部分浏览器调整字体只会导致字体显示大小发生改变，其他元素的大小不受影响。但对于结构稍微复杂一点的页面，字体大小的变动就足以导致页面布局乱掉，导致文本不居中、文字折行、布局混乱等问题。 原理： IOS：通过给 body 设置 -webkit-text-size-adjust 属性实现； Android：在CSS解析之后，渲染之前，将所有的字体大小的值进行缩放，后面的排版和渲染都会直接使用缩放后的CSS值。 1window.getComputedStyle(document.querySelector('.fs10'),null).getPropertyValue('font-size’)","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"css实现文字两端对齐","date":"2017-09-25T04:32:56.000Z","path":"2017/09/25/css实现文字两端对齐/","excerpt":"1. 需求：实现不同字的人名对齐 一般的处理方式用“空格”或者字符“&amp;nbsp;”来实现，但是人名太多，显然是不可能的。 css2中的text-align有个属性叫justify，可以实现两端对齐文本效果。 2. 简单的demo1234567&lt;div&gt; &lt;ul&gt; &lt;li&gt;梨华&lt;/li&gt; &lt;li&gt;白玉峰&lt;/li&gt; &lt;li&gt;欧阳予倩&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"移动端优化方案","date":"2017-09-23T05:56:49.000Z","path":"2017/09/23/移动端优化方案/","excerpt":"请求： 避免坏请求 CSS： 避免CSS @import 合并多个外部CSS文件 压缩CSS代码","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"移动端开发遇到的问题","date":"2017-09-22T05:56:20.000Z","path":"2017/09/22/移动端开发遇到的问题/","excerpt":"Meta标签 增加下面这个meta可以让页面强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户通过点击或者缩放等操作对屏幕放大浏览（这个在ios10以上的版本已经失效了，为了提高Safari中网站的辅助功能，即使网站在视口中设置了user-scalable = no，用户也可以手动缩放）： &lt;meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;\" name=\"viewport\" /&gt; 解决方法：监听事件来阻止 window.onload=function () { document.addEventListener('touchstart',function (event) { if(event.touches.length&gt;1){ event.preventDefault(); } }) var lastTouchEnd=0; document.addEventListener('touchend',function (event) { var now=(new Date()).getTime(); if(now-lastTouchEnd&lt;=300){ event.preventDefault(); } lastTouchEnd=now; },false) } 禁止ios自动识别电话： &lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt; 禁止ios自动识别邮箱： &lt;meta content=\"email=no\" name=\"format-detection\" /&gt;","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"js整理","date":"2017-09-20T05:54:13.000Z","path":"2017/09/20/js整理/","excerpt":"当new Foo()时发生了什么？ 创建了一个新对象； 将新创建的空对象的隐式原型指向其构造函数的显示原型； 将this指向这个新对象； 如果无返回值或返回一个非对象值，则将对象返回；如果返回值是一个新对象那么直接返回该对象； Ajax原理，怎么发送网络请求的？ 通过XMLHttpRequest/ActiveXObject新建Ajax请求 通过onreadystatechange注册回调函数 使用open、setRequestHeader、send结合发送请求 平常发送网络请求：用next做同构应用时，使用isomorphic-fetch发送请求，如果只是客户端发送请求时，使用axios call，apply，bind三者用法和区别： 共同点：都是用来改变函数的this对象的指向的。 参数：第一个参数都是this要指向的对象，也就是想指定的上下文（context） 绑定规则（显示绑定和强绑定） 运行效率（最终都会转换成一个一个的参数去运行） 运行情况（call，apply立即执行，bind是return出一个this“固定”的函数，bind是强绑定的原因） 注：“固定”这个词的含义，它指的固定是指只要传进去了 context，则 bind 中 return 出来的函数 this 便一直指向 context，除非 context 是个变量。闭包，作用域，this，call、apply、bind，变量提升","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"随笔测试","date":"2017-09-19T07:31:38.000Z","path":"2017/09/19/随笔测试/","excerpt":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Hello World","date":"2017-09-19T07:24:33.000Z","path":"2017/09/19/Hello-World/","excerpt":"","tags":[{"name":"开始","slug":"开始","permalink":"http://yoursite.com/tags/开始/"}]}]